<html>

<head>
<title>SS-Unit v0.9 Manual</title>
<meta name="author" content="Chris Oldwood">
<style>
<!--
body	{ font-family: Verdana, Arial; font-size: 10pt }
table	{ border-collapse: collapse }
th		{ font-family: Verdana, Arial; font-size: 10pt; border: 1px solid black }
td		{ font-family: Verdana, Arial; font-size: 10pt; border: 1px solid black; vertical-align: top; padding: 5px }
--></style>
</head>

<body>

<h3 align="center">SS-Unit v0.9</h3>

<a name="Introduction"></a>
<h4>Introduction</h4>

<p>
SS-Unit is a unit testing framework for SQL Server (i.e. T-SQL). It comprises
of a set of stored procedures that allow you to write unit tests for your SQL
objects and code in T-SQL itself using the familiar xUnit model. By this I mean
that the concepts of Fixtures, the SetUp & TearDown helper functions and use of
AssertXxx functions to verify expectations are all present. Naturally there are
limitations to T-SQL that make these concepts less accessible than in a language
like C# but they should be pretty easy to grasp.
</p><p>
For a little more rationale around why you might choose to unit test your SQL
code this way rather than through, say, your back-end services see my blog
posts <a href="http://chrisoldwood.blogspot.com/2011/04/you-write-your-sql-unit-tests-in-sql.html">You Write Your SQL Unit Tests in SQL?</a>
&amp; <a href="http://chrisoldwood.blogspot.com/2011/05/public-interface-of-database.html">The Public Interface of a Database</a>.
</p>

<hr>

<a name="Examples"></a>
<h4>The 'Examples' Database</h4>

<p>
The easiest way to see how SS-Unit works is to look at the examples which are
contained in the <code>SS-Unit\Examples</code> folder. The <code>*.dbo.sql</code>
files are intended to represent the production code and the <code>*.test.sql</code>
scripts are the unit tests. You can run the examples either in batch mode (just
as your build server would) this way:-
</p><pre>
C:\SS-Unit\Examples> BuildDatabase .\SQLEXPRESS
C:\SS-Unit\Examples> RunTests .\SQLEXPRESS
</pre><p>
or you can build the example database (with SS-Unit applied) and run the unit
test scripts interactively through a GUI tool such as SQL Server Management
Studio (SSMS):-
</p><pre>
C:\SS-Unit\Examples> BuildDatabase .\SQLEXPRESS
C:\SS-Unit\Examples> SSMS
</pre><p>
These batch files take the name of the SQL Server instance and assume a database
name of "SSUnit_Examples". The command line above shows how to access a local instance
of SQL Server Express which is freely available and makes an excellent tool for
developing SQL code via TDD as its limitations are beyond the scope of what unit
testing requires.
</p><p>
<b><i>NB: These batch files invoke <code>SQLCMD</code> to run the various .sql scripts and so
you need to have <code>SQLCMD</code> on your <code>PATH</code>.</i></b>
</p>

<hr>

<a name="Installation"></a>
<h4>Installation</h4>

<p>
Most unit test frameworks come with some sort of binaries, but because this is
SQL based it effectively comes as source code. It is intended that you apply
it to your baseline database schema and then run your set of test scripts.
There is a batch file in the Framework folder called <code>Install.cmd</code>
that you can use to load the test framework into any database, e.g.
</p><pre>
C:\SS-Unit\Framework> Install .\SQLEXPRESS SSUnit_Examples
</pre><p>
<i>The note above about the dependency on <code>SQLCMD</code> also applies to the
<code>Install.cmd</code> script.</i>
</p><p>
Most likely you will already have your code in some form of Version Control
System and also have some tool (or batch files) to create your baseline
database. Because this library comes in source form you can just add it to your
3rd party area and then either use the supplied batch file or manually integrate it
into your own build system.
</p><p>
The framework uses its own schema 'ssunit' and so there should be no conflicts
between the objects in the framework and your production codebase.
</p>

<hr>

<a name="Tutorial"></a>
<h4>Tutorial</h4>

<p>
It's assumed that you're already familiar with the xUnit testing framework -
probably NUnit - but if not, then as long as you have used one of the more
popular ones SS-Unit should make sense. As mentioned in the Introduction
some artistic license was required to map the mechanisms a language like C# has
at its disposal for metadata and reflection onto the much simpler T-SQL world.
</p>

<a name="HelloWorld"></a>
<h5>Hello World</h5>

<p>
So, let's start with the canonical unit test equivalent of the "Hello World"
program beloved by programmers everywhere:-
</p><pre>
create procedure test._@Test@_Assert_Hello_World
as
    declare @expected varchar(max);
    set     @expected = 'hello world';

    exec ssunit.AssertStringEqualTo @expected, 'hello world';
go

exec ssunit.RunTests;
</pre><p>
If you run this piece of code in SSMS (using, say, the SSUnit_Examples database)
you should see the following output:-
</p><img src="HelloWorldResult.gif"><p>
Alternatively you can save the query into a text file and run it with SQLCMD:-
</p><img src="HelloWorldConsole.gif"><p>
The first result set shows you that you ran 1 test; it passed and was called
"Assert_Hello_World". Below that is a second result set showing you a summary
of the test outcomes for that run.
</p>

<a name="HelloWorld"></a>
<h5>Hello SS-Unit</h5>

<p>
To make things a little more interesting, change either the expectation or the
actual value to something different and run the test again. I changed the actual
value to "hello ss-unit" and got this:-
</p><pre>
    exec ssunit.AssertStringEqualTo @expected, 'hello ss-unit';
</pre>
<img src="HelloSSUnitResult.gif"><p>
Grrr, our first failed test! This time the outcome has changed to "FAILED" and
the "Failure Reason" column is populated with a simple message that shows you
why the comparison failed.
</p>

<a name="HelloNobody"></a>
<h5>Hello Nobody</h5>

<p>
As one more final simple exercise, comment out the assert. This time the test
is deemed "inconclusive" and so the outcome changes to "Unknown":-
</p><pre>
    --exec ssunit.AssertStringEqualTo @expected, 'hello ss-unit';
</pre>
<img src="HelloNobodyResult.gif"><p>
It is expected that all code paths should assert <i>at least one</i> condition
to distinguish from the scenario where an assert has just been forgotten.
</p>

<a name="Mechanics"></a>
<h5>Test Mechanics</h5>

<p>
It should be pretty obvious that tests are written as stored procedures - one
procedure per test. It should also be apparent that the end of the SQL script
must contain a call to invoke the unit test runner (<code>exec ssunit.RunTests</code>)
at least when using a GUI tool like SSMS to run the tests.
What is probably less obvious is why there is
no <code>drop procedure</code> statement and why there are funny <code>_@</code>
characters in the name...
</p><p>
If you've used NUnit you'll be accustomed to annotating your unit tests with a
<code>[Test]</code> attribute. This is how NUnit finds your tests without you
having to register them. Sadly T-SQL doesn't support attributes and so we have
to find another way to achieve the same effect. So, it uses an adornment on the
test name instead: <code>_@Test@_</code>. Hopefully the use of the '@' symbol will
make you think <b>at</b><i>tribute</i>. So these two are supposedly equivalent:-
</p><pre>
[Test]
public void Thing_ShouldDoThat_WhenItDoesThis()
{
. . .
}

create procedure _@Test@_Thing_ShouldDoThat_WhenItDoesThis
as
. . .
go
</pre><p>
As for why you don't need to write the usual <code>if object_id()/drop procedure</code>
prologue, that's because the test framework drops the procedure for you. Why?
Because unit test names <i>should be verbose</i> and nothing kills your flow
more than having to fix your script because you forgot to drop the proc first or
you misspelled it. This <i>then</i> means that you can alternate between the production
code and writing/running the tests very rapidly.
</p><p>
A slightly more subtle point you may have noticed is that all the SS-Unit
objects live in a separate schema called <code>ssunit</code>. This gives it all
the benefits of namespaces to avoid name clashes with your test or production
code. The test runner assumes that all tests live in a schema called <code>test</code>
but that can be overridden as explained later.
</p>

<a name="Asserts"></a>
<h5>Asserts</h5>

<p>
Due to the limitations of T-SQL not supporting overloading based on type the
assert names have to encode the type instead. So far only a basic set of assert
procedures have been written for the core types - integers, strings and datetimes.
Given that SQL Server will do most convert type conversions automatically you
can still get a lot done with just these few:-
</p>
<table id="asserts">
<tr>
<th>Assert Procedure</th>
<th>Description</th>
</tr>
<tr>
<td>AssertPass</td>
<td>Denotes the test as having conclusively passed</td>
</tr>
<tr>
<td>AssertFail</td>
<td>Denotes the test as having conclusively failed</td>
</tr>
<tr>
<td>AssertNotImplemented</td>
<td>Fails the test with a reason of "Not implemented"</td>
</tr>
<tr>
<td>AssertTrue</td>
<td>Compares the resultant value to 1 (i.e. true)</td>
</tr>
<tr>
<td>AssertFalse</td>
<td>Compares the resultant value to 0 (i.e. false)</td>
</tr>
<tr>
<td>AssertThrew</td>
<td>Executes a helper procedure which performs the test and should result in an error being thrown</td>
</tr>
<tr>
<td>Assert<i>Xxx</i>EqualTo</td>
<td>Compares the resultant Xxx value to another for equivalence</td>
</tr>
<tr>
<td>Assert<i>Xxx</i>NotEqualTo</td>
<td>Compares the resultant Xxx value to another for a difference</td>
</tr>
<tr>
<td>Assert<i>Xxx</i>LessThan</td>
<td>Performs a &lt; comparison with the resultant Xxx value</td>
</tr>
<tr>
<td>Assert<i>Xxx</i>LessThanOrEqualTo</td>
<td>Performs a &lt;= comparison with the resultant Xxx value</td>
</tr>
<tr>
<td>Assert<i>Xxx</i>GreaterThan</td>
<td>Performs a &gt; comparison with the resultant Xxx value</td>
</tr>
<tr>
<td>Assert<i>Xxx</i>GreaterThanOrEqualTo</td>
<td>Performs a &gt;= comparison with the resultant Xxx value</td>
</tr>
<tr>
<td>Assert<i>Xxx</i>IsNull</td>
<td>Compares the resultant Xxx value to NULL</td>
</tr>
<tr>
<td>AssertIntegerBetween</td>
<td>Compares an integer to a range (lower and upper bounds are inclusive)</td>
</tr>
<tr>
<td>AssertStringLike</td>
<td>Compares two strings using the <code>LIKE</code> operator for a match</td>
</tr>
<tr>
<td>AssertStringNotLike</td>
<td>Compares two strings using the <code>LIKE</code> operator for a difference</td>
</tr>
</table>
<p>
<i>NB: AssertPass and AssertFail provide the underpinnings of the framework - all
others are implemented in terms of these two.</i>
</p><p>
You will notice that each 'set' of asserts has an explicit overload for comparing
with NULL. It would have been quite easy to make the AssertXxxEqualTo procedures
support a comparison with NULL, but I felt that goes against how NULL's are
handled in real SQL. You learn early on that NULL can be synonymous for
'unknown' and so you never write "x = null", but "x is null". Consequently in
SS-Unit you don't say "AssertXxxEqualTo null, @x", but "AssertXxxIsNull @x". 
</p>

<a name="AssertThrew"></a>
<h5>AssertThrew</h5>

<p>
SQL Server provides a Try/Catch mechanism that allows you to use an exception
style of programming to deal with errors via the <code>RAISERROR</code> keyword. However,
writing a unit test to verify that an action throws can be very verbose; so to
avoid the boilerplate code obscuring the salient part of the test the
<code>AssertThrew</code> procedure takes an extra argument that is the name of
a helper procedure to invoke as part of the test, e.g. 
</p><pre>
create procedure test._@Helper@_My_Procedure_That_Throws
as
    -- simulate a constraint violation
    raiserror('my error', 16, 1);
go

create procedure test._@Test@_ShouldThrow
as
    exec ssunit.AssertThrew 'my error', 'test._@Helper@_My_Procedure_That_Throws';
go
</pre><p>
There are also two failure modes of an <code>AssertThrew</code> style test as
opposed to the usual one. First the helper procedure may not cause an error to
be thrown, and secondly the error that is thrown may not the one expected - hence
the <code>@error</code> argument. For example, when testing constraints, it's too
easy to write a test that causes a primary key or <i>different</i> foreign key
violation by accident instead of the desired failure and so you need the extra
comparison.
</p><p>
The problem with scraping error messages to verify a test is that they are
subject to change, at least for application specific errors. And so the message
comparison is done using the <code>LIKE</code> operator so that you can perform
a fuzzy match. One benefit to explicitly naming your constraints is that you can
then use them as the <code>@error</code> message instead of something more
vague, e.g.
</p><pre>
    -- Matches any FK violation
    exec ssunit.AssertThrew '%FOREIGN KEY%constraint%', 'test._@Helper@_My_Procedure_That_Throws';

    -- Matches specific constraint violation through constraint name
    exec ssunit.AssertThrew '%MyTable_FK_MyColumn%', 'test._@Helper@_My_Procedure_That_Throws';
</pre><p>
The <code>_@Helper@_</code> attribute is used to indicate a helper procedure
that should also be deleted once the tests have run. If the attribute is not
applied then it must be handled either with the <code>TestSchema_Clear</code>
utility procedure or manually with a traditional <code>drop procedure</code>
call.
</p>

<a name="Fixtures"></a>
<h5>SetUp & TearDown Helper Procedures</h5>

<p>
One technique for reducing noise and improving performance within the
<i>arrangement</i> phase of a test is to factor out code into a helper function.
The xUnit framework generally provides two mechanisms for two separate
pairs of helper methods - one pair run per-test and the other pair run
per-fixture. Within each pair the "SetUp" method is run before the test(s) and
the "TearDown" method after.
</p><p>
In NUnit the first pair of methods are annotated with the <code>[TestSetUp]</code>
and <code>[TestTearDown]</code> attributes, which in SS-Unit is mapped to the
name adornments <code>_@TestSetUp@_</code> and <code>_@TestTearDown@_</code>.
Naturally it follows that the fixture-level pair in SS-Unit are similarly named
<code>_@FixtureSetUp@_</code> and <code>_@FixtureTearDown@_</code>. In both
cases the rest of the procedure name is irrelevant and can be left off if so
desired. Each of the four helper procedures is optional too, so you can leave
out any that you don't need. 
</p><p>
This just leaves the question of how you define a fixture. In NUnit it is the
name of the class that contains the test methods, but there are no classes in
T-SQL and so once again we must look to adorn the test name. This time we
use the format <code>_$FixtureName$_</code>. So, putting this all together we
have the following example of how to write a test that has both fixture-level
and test-level SetUp & TearDown helpers:-
</p><pre>
create procedure test._@FixtureSetUp@_$CounterTests$_
as
    create table test.TestCounter
    (
        Value int
    );

    insert into test.TestCounter(Value) values(1);
go

create procedure test._@FixtureTearDown@_$CounterTests$_
as
    drop table test.TestCounter;
go

create procedure test._@TestSetUp@_$CounterTests$_
as
    update test.TestCounter
    set    Value = Value + 10;
go

create procedure test._@TestTearDown@_$CounterTests$_
as
    update test.TestCounter
    set    Value = 1;
go

create procedure test._@Test@_$CounterTests$_CounterShouldEqualElevenAfterSetUp
as
    declare @value int;
    select  @value = Value from test.TestCounter;

    exec ssunit.AssertIntegerEqualTo 11, @value;
go

exec ssunit.RunTests;
</pre><p>
There is no restriction on the number of fixtures and tests that you can define
in a single script. If you prefer you can run all the test creation scripts in
one phase and then execute <code>ssunit.RunTests</code> right at the end in one
go.
</p>

<a name="TestRunner"></a>
<h5>Test Runner Parameters</h5>

<p>
The procedure you invoke to run the test suite (<code>ssunit.RunTests</code>)
supports a number of parameters to control various aspects of test execution
and reporting:-
</p>
<table id="parameters">
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
<tr>
<td>@schemaName</td>
<td>Specify this if you want to run tests in a schema other than 'test'</td>
</tr>
<tr>
<td>@displayWidth</td>
<td>When running in '<a href="#DisplayWidth">batch mode</a>' the console width is
    assumed to be 80 chars wide, use this parameter to widen or truncate the output</td>
</tr>
<tr>
<td>@reportResults</td>
<td>An enumeration value used to control the output of the per-test results (see blow)</td>
</tr>
<tr>
<td>@reportSummary</td>
<td>An enumeration value used to control the output of the results summary (see blow)</td>
</tr>
<tr>
<td>@isInteractive</td>
<td>Override the SQL client type by setting this to 0 for batch mode and 1 for interactive</td>
</tr>
</table>
<p>
The following example shows how to use a different schema and
<a href="#DisplayWidth">widen the output</a> when running in batch mode:-
</p><pre>
exec ssunit.RunTests @schemaName = 'unit_test',
                     @displayWidth = 180;
</pre><p>
The <code>@reportResults</code> and <code>@reportSummary</code> parameters are
enumeration values of the pseudo-type <code>ssunit.ReportCondition</code>.
Essentially this is a <code>tinyint</code> value with UDFs taking the place of
the enumeration symbols (so you don't hard-code a literal value):-
</p>
<table id="Table1">
<tr>
<th>Value</th>
<th>Symbol</th>
<th>Description</th>
</tr>
<tr>
<td>Never</td>
<td>ReportCondition_Never</td>
<td>Never generate the report</td>
</tr>
<tr>
<td>Always</td>
<td>ReportCondition_Always</td>
<td>Always generate the report</td>
</tr>
<tr>
<td>On Failure</td>
<td>ReportCondition_OnFailure</td>
<td>Only generate the report when at least one test has failed</td>
</tr>
</table>
<p>
The following example shows how to configure the runner to only generate the
per-test results when a test has failed:-
</p><pre>
declare @onFailure ssunit.ReportCondition = ssunit.ReportCondition_OnFailure();

exec ssunit.RunTests @reportResults = @onFailure;
</pre><p>
For more details about using UDFs to encapsulate constants and enumerations see
my blog post <a href="http://chrisoldwood.blogspot.co.uk/2010/09/implementing-constants-enumerations-in.html">Implementing Constants & Enumerations in a Database</a>.
</p>

<a name="GlobalParameters"></a>
<h5>Global Parameters</h5>

<p>
To reduce the noise within each test script and ease the burden of constantly
setting the test runner parameters there is a global collection of these
that only need to be set once. You still have the option to override these
defaults on a per-script basis by passing different values when invoking
<code>ssunit.RunTests</code>. The table below lists the parameters and the
API procedure used to set its default:-
</p>
<table id="globals">
<tr>
<th>Parameter</th>
<th>API Procedure</th>
</tr>
<tr>
<td>@schemaName</td>
<td>ssunit.Configuration_SetSchemaNameDefault</td>
</tr>
<tr>
<td>@displayWidth</td>
<td>ssunit.Configuration_SetDisplayWidthDefault</td>
</tr>
<tr>
<td>@reportResults</td>
<td>ssunit.Configuration_SetReportResultsDefault</td>
</tr>
<tr>
<td>@reportSummary</td>
<td>ssunit.Configuration_SetReportSummaryDefault</td>
</tr>
</table>
<p>
NB: The @isInteractive parameter was added to aid in testing SS-Unit and as a
workaround for when the UDF <code>ssunit.IsInteractive()</code> doesn't correctly
categorise the client so there is no way to override the default.
</p>

<a name="DisplayWidth"></a>
<h5>Console Display Width</h5>

<p>
The framework has the notion of whether the tests are being run interactively,
such as via SSMS, or in batch mode via a command line tool like SQLCMD. This
discovery is done by the UDF <code>ssunit.IsInteractive()</code> which just
queries the built-in <code>app_name()</code> function and matches it to known
SQL clients.
</p><p>
The <code>@displayWidth</code> parameter is only used in batch mode and allows
the runner to size the "Test Name" and "Failure Reason" columns to avoid ugly
text wrapping in a console window. When running as part of an automated build you are probably
redirecting the output and so effectively want to configure an "infinitely wide"
console instead.
</p><p>
As of v1.0 the SS-Unit framework test script (<code>RunTests.cmd</code>) uses
the <a href="#GlobalParameters">global parameters</a> feature to set the display
width once by invoking the relevant procedure:-
</p><pre>
set displayWidth=120
. . .
sqlcmd -E -S %server% -d %database% -Q "exec ssunit.Configuration_SetDisplayWidthDefault %displayWidth%"
</pre><p>
Prior to v1.0 the test script used the <i>variables</i> feature of SQLCMD to 
inject the display width into the test script at run time:-
</p><pre>
set displayWidth=120
. . .
sqlcmd -E -S %server% -d %database% -i "%%f" -v DisplayWidth=%displayWidth%
</pre><p>
Then in the SQL test script you need to parse that into an int so it can be
supplied to <code>RunTests</code>. You also need to remember that the same script
run under SSMS will not substitute the variable and so you need to guard
against it causing an error:-
</p><pre>
declare @displayWidth int = case when (isnumeric('$(DisplayWidth)') = 0)
                                 then 80
                                 else convert(int, '$(DisplayWidth)')
                            end;

exec ssunit.RunTests @displayWidth = @displayWidth;
</pre>

<hr>

<a name="Warranty"></a>
<h4>License & Warranty</h4>

<p>
This library is freeware - you get what you pay for, nothing more, nothing less.
</p>

<a name="Contact"></a>
<h4>Contact Details</h4>

<p>
Please check the web site for updates.
</p><p>
Email: <a href="mailto://gort@cix.co.uk">gort@cix.co.uk</a><br>
Web: <a href="http://www.cix.co.uk/~gort">www.cix.co.uk/~gort</a><br>
</p><p>
Chris Oldwood<br>
10th November 2011<br>
</p>

</body>

</html>
